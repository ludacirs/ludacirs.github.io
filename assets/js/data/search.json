[ { "title": "React Query", "url": "/posts/React_Query/", "categories": "React, React-Query", "tags": "React, React-Query, state", "date": "2022-03-04 03:08:00 +0900", "snippet": "React-Query상태 분리하기리액트를 다룰 때 상태를 이용해서 뷰를 렌더링한다.프론트에서 표현하는 데이터가 많아지면서 상태도 상당히 늘어났다. 그중 대표적인 것이 서버에서 받아오는 데이터이러한 데이터들은 보통 전역에서 관리해야되거나, 복잡한 로직을 가지고 있는 경우가 많기 때문에 상태관리 라이브러리의 힘을 빌리는 경우가 많다.많은 경우 리덕스의 미들웨어를 사용해서 이를 해결해왔다.이런 흐름으로 자연스럽게 API 통신을 위한 코드는 전역 상태관리 라이브러리(리덕스)에게 위임하는게 당연시 되어버렸는데클라이언트 내부에서만 선언하고 다루어지며 항상 최신의 상태로 업데이트되어 뷰에 반영되는 상태와 서버 데이터의 스냅샷을 불러와서 최신임을 보장할 수 없고 모두가 다룰 수 있어 최신임을 보장할 수 없는 상태이 둘은 다른 방식으로 다루어야 효율적인 앱을 만들 수 있다… 해서 나온 것이 React-Query, SWR, RTK-Query 등과 같은 라이브러리들이다.무엇?처음에는 위의 개념을 보고는 아 요즘엔 이런식으로 개발하는구나 생각하고있다가next.js로 진행하고 있는 사이드 프로젝트에서 SSG로 스태틱 페이지만 뽑아내고 있다가 SSR로 개발해야되는 페이지가 생겨서 저런식으로 개발하기로 마음을 먹었다.React-Query리덕스를 사용해본적이 있는데다가 가장 대중적이고 정보량도 많을 거라는 생각에 리덕스로 클라이언트 상태 + 리덕스 쿼리로 서버 상태 관리를 할 셈이었는데 공식 문서를 읽고 적용해봐도 잘 안되고.. 검색해봐도 정보량이 얼마 나오지 않아서 포기하고 React-Query를 사용하기로 결정간략하게 요약하면 React-Query는 서버에서 가져온 데이터의 스냅샷을 정해진 기간(staleTime)만큼 캐싱(저장)해서 보관하고 있다가 기간이 넘어가면 해당 스냅샷을 업데이트(refetch)해주는 과정을 처리해주는 라이브러리라고 할 수 있다.배우며 헷갈렸던 부분만 간단히 적어보면어휘 및 개념 fresh: 새롭게 추가된 쿼리 인스턴스로 가장 최신의 상태를 말한다. 추가된 시점부터 active이며 이를 기준으로 설정해준 staleTime(기본값 0)에 따라서 fresh =&amp;gt;stale 상태로 변한다. feching: 요청, 재요청 수행중인 쿼리 loading: 데이터가 없는 상태에서의 (첫)요청을 수행 중인 쿼리 inactive: 컴포넌트가 언마운트 되고 나서의 쿼리 상태를 가르킨다. cacheTime(기본값 5분)동안 데이터가 캐싱된다. cacheTime이 넘어가면 캐시에서 delete된다.생명 주기fetching =&amp;gt; active(fresh state) =&amp;gt; (staleTime =&amp;gt; stale state =&amp;gt;) unmount =&amp;gt; inactive =&amp;gt; cacheTime =&amp;gt; deletestale vs cachestaleTime이 지난 쿼리는 말대로 stale한 상태가 되며 refetch의 대상이된다. staleTime이 지난 query는 컴포넌트가 재렌더링될 때 refetch된다. staleTime이 지나지 않은 query는 컴포넌트가 재렌더링될 때 refetch하지 않고 캐시된 데이터를 가져온다. staleTime이 지나지 않은 query의 컴포넌트가 언마운트되고 cacheTime이 지나기전에 재렌더링될 때 refetch하지 않고 캐시된 데이터를 가져온다. staleTime이 지난 query의 컴포넌트가 언마운트되고 cacheTime이 지나기전에 재렌더링될 때 캐시된 데이터를 가져와서 보여주고 refetch 후에 데이터를 최신 값으로 바꾼다. staleTime이 무기한인 경우 QueryClient 인스턴스로 invalidate(키값)으로 리패칭할 수 있다.queries 파일은 분리컴포넌트 내부에서 사용하면 키 등 때문에 관리가 힘들 수 있다. 도메인 별로 분리를 추천동일한 키값을 가진 쿼리들은 모두 상태를 공유한다.staleTime이 100초인 쿼리를 A 컴포넌트에서 부르고 100초 내에 B 컴포넌트에서 동일한 키값을 가진 쿼리를 불러오면 패칭하지 않고 캐시된 데이터를 가져온다. -&amp;gt; React Query가 내부적으로 Context API를 사용하기 때문에 마치 전역 상태관리하는 것 처럼 사용할 수 있음.자주 사용되는 옵션 onSucess : 성공했을 때 실행될 콜백을 정의 onError: 에러가 발생했을 때 실행될 콜백을 정의 onSettled: 완료시의 실행될 콜백을 정의 select: 성공시 가져온 데이터를 가공하는 콜백을 정의 refetchInterval: 주기적으로 refetch할지 결정하는 옵션 enabled: 기본적으로 쿼리가 담긴 컴포넌트가 마운트될 때 쿼리가 실행되는데 이 옵션을 false로 주면 안함useMutationCRUD에서 CUD의 API 요청 할 때 사용 onMutate: Optimistic update(낙관적 업데이트) 내가 보낸 요청이 성공할 것이라고 보고 성공을 예상하여 UI나 다른 로직을 미리 실행시킬 수 있다. 만약 성공하지 못하고 실패하면…? 그 이전의 상태로 롤백한다.useInfiniteQuery연속적으로 요청해야하는 API(무한스크롤 등)을 위해 나온 hookconst useGetInfiniteTalks = (agoraId: number) =&amp;gt; { const { data, isLoading, fetchNextPage } = useInfiniteQuery&amp;lt;ITalkList&amp;gt;( [&#39;getTalks&#39;, agoraId], ({ pageParam }) =&amp;gt; getTalks({ roomId: +agoraId, cur: pageParam }), { getNextPageParam: lastPage =&amp;gt; { return lastPage.hasNext ? lastPage.lastIndex : null; }, }, ); return { pages: data?.pages, isLoading: isLoading, lastIndex: data?.pageParams, fetchNextPage, };}; 여기서 반환값의 data는 pages라는 배열을 갖는다. data.pages = [{ hasNext: boolean, lastIndex: number, 결과값: any,}, ...,] pages 안에는 하나의 요청당 하나의 page가 계속해서 쌓인다. getNextPageParam는 pageParam의 값을 설정해줄 수 있는 콜백위 코드에서는 lastPage로 마지막으로 불러온 데이터의 hasNext와 lastIndex를 조회해서 다음 불러올 페이지가 있다면 기준이 될 cursorId를 pageParams로 넘겨주고 없다면 null값을 전달해준다. fetchNextPage위에서 설정한 pageParam을 기준으로 다음 쿼리를 실행하게 하는 함수 실행하게되면 pages에 page가 추가된다." }, { "title": "Redux", "url": "/posts/Redux/", "categories": "React, Redux", "tags": "React, Redux, toolkit", "date": "2022-02-24 03:44:00 +0900", "snippet": "Redux리덕스는 이전에 블로그를 만들면서 살짝 다뤄본 적이 있는데 아무 생각없이 따라서 만들기만해서 사실 모르는 것에 가까워서 복습.왜 사용해야할까?사실 잘 모르겠다리덕스를 이제서야 공부하는 이유 중 하나이기도 한데여태까지 작업한 사이드 프로젝트에서는 context와 useReducer를 이용해서 충분히 상태관리가 가능했기 때문에 리덕스에 눈돌리지 않아서 계속 미루고 있었다하지만 최근에 작업하는 프로젝트에 기능을 조금씩 붙이다보니 전역으로 관리해야할 상태가 늘어나고, Provider가 충첩되며, 서버에서 받아오는 데이터를 관리하기가 까다로워짐에 따라서 다른 상태관리 툴이 필요하다고 판단되어 눈이 조금씩 돌아가는 중조금 공부하다 보니 최근에는 서버쪽 데이터를 React Query나 SWR, rtk-query를 사용해서 또 한 번 분리하는 흐름으로 움직이던데리덕스가 가장 오래되고 사용량이 많으니까 redux =&amp;gt; rtk-query =&amp;gt; React Query 순으로 공부하려고 한다.redux-toolkit리덕스를 도입하지 않은 이유 중 하나가 보일러 플레이트 코드 작성이 너무 많아서 이다.액션을 정의하고, 그 액션 생성함수를 만들고, 초기 상태값을 만들어서 넣어주고, 리듀서도 작성하고, 리듀서를 또 합치고, 미들웨어도 붙여주고..관리해야할 상태나 액션이 늘어나면 또 위의 작업을 반복하고, 거기에 타입스크립트를 쓰고 있다면 타입추론이 굉장히 힘들다.그 불편함들을 모두 해소해주는게 리덕스에서 만든 redux-toolkit인데 공식적으로 쓰는 걸 추천하고 있으니 redux-toolkit으로 진행한다.slice하나의 리듀서에 들어가는 액션, 액션 생성자, 리듀서, 초기 상태 4가지를 slice라고 부르는데 createSlice 메서드를 통해서 한 번에 정의할 수 있다.import { createSlice, PayloadAction } from &quot;@reduxjs/toolkit&quot;;interface CounterState { value: number;}// 초기 상태값 설정const initialState: CounterState = { value: 0,};const counterSlice = createSlice({ // slice 이름 name: &quot;counter&quot;, // 초기값 부여 initialState, // 리듀서 reducers: { increment(state) { state.value += 1; }, decrement(state) { state.value -= 1; }, incrementByAmount(state, action: PayloadAction&amp;lt;number&amp;gt;) { state.value += action.payload; }, decrementByAmount(state, {payload}: PayloadAction&amp;lt;number&amp;gt;) { state.value -= payload; }, },});export default counterSlice;이렇게 정의해주게되면 counterSlice에 위에서 말한 4가지를 라이브러리가 모두 정의해준다.약간 의아한 점은 redux tutorial 템플릿에서 제공해주는 코드에는 ` incrementByAmount(state, action: PayloadAction)`와 같이 type과 payload가 들어가있는 action을 인자로 받고 있는 것을 볼 수 있는데 그 밑의 액션 처럼 `decrementByAmount(state, {payload}: PayloadAction)`같이 써야하는게 아닌가 생각이 든다createSlice 내부에 있는 reducer로직에서는 개발자가 이미 판단된 action에 대해서 type값을 사용할 일이 없을 것 같은데 왜 payload만 받지 않고 type이 같이 들어간 action을 받는게 default값인지 모르겠다는 점잘은 모르지만 미들웨어같은 걸 도입할 때 reducer 로직 내부에서 action의 type값을 사용할 일이 있는 걸까?그리고 reducers 내부에 정의되는 로직들은 불변성을 신경써줄 필요가 없이 라이브러리가 불변성을 가지고 업데이트를 시켜준다.acitons액션 생성자들은 다음과 같이 편하게 뽑아올 수 있다.export const { increment, decrement, incrementByAmount, decrementByAmount } = counterSlice.actions;configureStoreconfigureStore는 기존의 createStore로 하던 부분을 추상화한 함수로 기존에 개발자가 직접해야했던 설정들을 기본적으로 해준다.import { configureStore } from &#39;@reduxjs/toolkit&#39;import rootReducer from &#39;./reducers&#39;const store = configureStore({ reducer: rootReducer })이처럼 타이핑하면 Redux DevTools가 활성화되고, redux-thunk가 추가된다.좀 더 자세한 설정을 보면const store = configureStore({ reducer, middleware: (getDefaultMiddleware) =&amp;gt; getDefaultMiddleware().concat(logger), devTools: process.env.NODE_ENV !== &#39;production&#39;, preloadedState, enhancers: [reduxBatch],})다른것들은 다 명시적이라 설명이 필요 없을 것 같고 preloadedState: 스토어의 초기값을 설정할 수 있다. enchaners: 기본적으로 배열이며 콜백 함수로 정의되기도 한다. 미들웨어의 순서를 설정하는 옵션사용하기const dispatch = useDispatch();const { ... } = useSelector((state) =&amp;gt; state);평소처럼 이렇게 사용하면 되겠지만 이러면 typescript와 사용하기 힘들고, 장점을 살릴 수도 없다.그래서 useDispatch와 useSelector를 한 번 가공해주어야한다.export const useAppDispatch = () =&amp;gt; useDispatch&amp;lt;{현재 사용하고 있는 리덕스 디스패치의 타입}&amp;gt;();export const useAppSelector: TypedUseSelectorHook&amp;lt;{현재 사용하고 있는 리덕스 state의 타입}&amp;gt; = useSelector;이 훅들을 정의해서 사용하면 디스패치를 사용할 때 기존에 정의되지 않은 액션들이 들어올 때 에러를 발견할 수 있고, useSelector를 사용할 때 자동완성의 힘을 빌릴 수 있다.중괄호 안에 있는 타입들은 configureStore를 정의한 곳에서 뽑아낼 수 있다.const store = configureStore({ reducer: rootReducer })export type AppDispatch = typeof store.dispatch;export type RootState = ReturnType&amp;lt;typeof store.getState&amp;gt;;비동기 액션RTK에는 기본적으로 redux-thunk와 thunk 액션 생성 함수가 내장되어있고, 이를 이용해서 간단하게 비동기 로직을 적용할 수 있다.export const incrementAsync = createAsyncThunk( &quot;counter/incrementAsync&quot;, async (amount: number) =&amp;gt; { const response = await new Promise&amp;lt;{ data: number }&amp;gt;((resolve) =&amp;gt; { setTimeout(() =&amp;gt; { resolve({ data: amount }); }, 1000); }); return response.data; });1초 뒤 data를 반환하는 덩크를 만들었다.이 덩크에 해당하는 액션이 들어오면 내부의 Promise값의 진행도에 따라서 reducer에 counter/incrementAsync/pending, counter/incrementAsync/fulfilled, counter/incrementAsync/reject의 액션이 자동으로 reducer로 들어가게된다thunk 액션은 reducer 내부에 정의할 수 없기 때문에 외부에서 만들어져 들어오는 action을 처리하기 위한 extraReducers의 콜백에 해당 로직들을 정의한다.const counterSlice = createSlice({ name: &quot;counter&quot;, initialState, reducers: { //... }, extraReducers: (builder) =&amp;gt; { builder .addCase(incrementAsync.pending, (state) =&amp;gt; { console.log(&quot;pending...&quot;); state.wait = true; }) .addCase(incrementAsync.fulfilled, (state, action) =&amp;gt; { console.log(&quot;done.&quot;); console.log(action); state.wait = false; state.value += action.payload; }); },});콜백은 builder 파라미터를 받으며 builder는 addCase, addMatcher, addDefaultCase 3가지 메서드를 제공하며 각각 chaining이 가능하게 builder 스스로를 반환한다. addCase: switch 문에서 리듀서를 정의할 때 쓰는 case와 동일하다. addMatcher: 여러 액션을 묶어서 처리할 때 사용. isAnyOf, isAllOf 과 같이 제공되는 메서드를 이용 addDefaultCase: default 와 동일위에서 말했듯이 3가지 상태로 extarReducers에 전달되며 이전과 같이 state값을 수정해주면 불변성을 유지하며 상태가 업데이트된다.에러 핸들링reducer에서createAsyncThunk가 반환하는 promise는 결과와 상관없이 항상 이행된(fulfilled)상태로 반환해준다.그래서 에러를 잡기 위해서는 조금 더 손을 써줘야한다.export const someAsync = createAsyncThunk( &quot;someAsync&quot;, async () =&amp;gt; { try{ const response = await fetchData(); return response.data; } catch (e){ return e; } }); 무조건 fulfilled를 반환한다는 것은 위의 fetchData()에서 데이터를 제대로 불러오지못해서 에러가 발생해도 fulfilled 처리되어 ` .addCase(incrementAsync.fulfilled, (state, action)`문이 실행된다.에러가 발생했는데도 콘솔에는 done.이 찍히는 모습export const someAsync = createAsyncThunk( &quot;someAsync&quot;, async (_, { rejectWithValue }) =&amp;gt; { try{ const response = await fetchData(); return response.data; } catch (e){ return rejectWithValue(e); } });덩크 생성자의 두번째 파라미터에 rejectWithValue를 이용하면 reject된 promise를 보낼 수 있다.컴포넌트 내부에서리듀서에서도 에러핸들링을 할 수 있지만 컴포넌트 내부에서도 할 수 있다.이 쪽이 컴포넌트 별로 다르게 에러를 핸들링할 수 있다는 점에서 조금 더 권장되는 방법import { unwrapResult } from &quot;@reduxjs/toolkit&quot;;const handleEvent = async () =&amp;gt; { try { const resultAction = await dispatch(asyncFucntion(value)); const fulfilled = unwrapResult(resultAction); //성공 } catch (reject) { //실패 }};디스패치로 받아온 결과값을 unwrapResult 메서드로 벗겨내는 과정에서 결과값이 정상이면 성공 로직을 에러가 난다면 catch문에서 실패 로직을 처리해주면된다.비동기 취소하기시작 전createAsyncThunk의 3번째 인자로 들어가는 option에서 condition 콜백에서 true, false로 비동기 로직 시작 전에 취소시킬 수가 있다.condition의 첫 번째 인자 : 덩크를 실행시킬 때 전달받은 값condition의 두 번째 인자 : Pick&amp;lt;thunkAPI, ‘getState’, ‘extra’&amp;gt;export const someAsync = createAsyncThunk( &quot;someAsync&quot;, async (_) =&amp;gt; { try{ const response = await fetchData(); return response.data; } catch (e){ return rejectWithValue(e); } }, { conditon: (_, {getState, extra}) =&amp;gt;{ // 비교로직 }});보통 첫 번째 인자로 받은 값과 getState로 현재 state를 비교해서 true/false로 취소 결정을 하는 것 같다시작 중이미 시작되어버린 비동기 로직도 디스패치의 promise.abort() 메서드를 통해 취소하는 것이 가능하다.const handleEvent = () =&amp;gt; { const promise = dispatch(asyncFucntion(value)); promise.abort();};" }, { "title": "V8 엔진의 메모리 관리", "url": "/posts/V8_Memory/", "categories": "CS, Web", "tags": "V8, 가비지, 컬렉터", "date": "2022-01-09 22:24:00 +0900", "snippet": "V8 메모리 관리nodejs는 자바스크립트로 이루어져있고 자바스크립트는 V8엔진에 의해서 돌아간다가비지 컬렉터의 작동하는 방식, 코드를 작성할 때 백그라운드에서 발생하는 일, 메모리가 해제되는 방식을 알아보자메모리 영역V8의 메모리공간을 Resident Set이라 부른다. 메모리 세그먼트는 아래와 같이 나뉜다 Code : 실행될 코드들 Stack : heap에 있는 object를 참조하는 포인터, 원시타입들이 있다. Heap : object, string, 클로저와 같은 레퍼런스 타입을 저장한다.힙 새 영역(new space) 새 할당이 발생하는 영역, 대부분의 객체들이 여기에 있다. 잦은 GC가 발생하기 때문에 빠르게 GC될수 있도록 설계되었다. 메모리 크긴느 1~8MB 사이이며, Young Generation이라고도 부른다. 20% 정도가 old space로 장기화된다. 오래된 영역(old space) : GC가 두 번 발생할 동안 “New 영역”에서 살아남은 객체들이 이동하는 영역 Old 포인터 영역: 살아남은 객체들을 가지며, 이 객체들은 다른 객체를 참조 Old 데이터 영역: Old 포인터에 가지 않은 살아남은 변수들. 문자열, 박싱(boxing)된 숫자, 실수형(double)로 언박싱(unboxing)된 배열 라지 오브젝트 영역(Large-object space) 다른 space의 크기 제약보다 큰 크기를 가지는 객체들이 저장 각 객체들은 고유의 memory-mapped 영역을 가지며, Garbage collector에 의해 수집되지 않는다 코드 영역 (Code space) Just-In-Time 컴파일된 인스트럭션을 포함하는 코드 객체들이 저장된다. 실행 가능한 메모리를 가지는 유일한 space이다. Cell space, Property-cell space, Map space 각각 Cells, Property-Cells, Maps가 저장된다. 이 공간들에 위치한 객체들은 모두 그 크기와 타입이 같아서 GC가 쉽다. 스택V8 프로세스마다 하나의 스택을 가진다메모리 관리프로그램이 제대로 작동하려면 메모리가 필요하고 그 때문에 메모리 관리가 필요하다응용프로그램 수준에서 메모리 관리는 자동/수동으로 나뉘는데 대부분의 프로그램들의 자동 메모리 관리는 가비지 콜렉터가 맡고 있다수동으로 메모리를 관리는 C언어등에서 malloc, free 등을 통해 관리하는 것이다수동 메모리 관리에서 주로 발생할 수 있는 버그들 사용한 메모리 공간을 반환하지 않으면 메모리 누수가 발생한다 개체된 객체의 포인터가 재사용되면 중요한 정보를 읽을 때 심각한 보안 문제가 발생할 수 있다Node.js에는 가비지 수집기가 포함되어 있으므로 메모리 할당을 수동으로 관리할 필요가 없다가비지 컬렉터의 개념참조를 잃어 더이상 사용할 수 없는 객체들을 가비지 컬렉터가 자동으로 수집해서 메모리를 반환시켜준다function Engine (power) { this.power = power}function Car (opts) { this.name = opts.name this.engine = new Engine(opts.power)}let LightningMcQueen = new Car({name: &#39;Lightning McQueen&#39;, power: 900})let SallyCarrera = new Car({name: &#39;Sally Carrera&#39;, power: 500})let Mater = new Car({name: &#39;Mater&#39;, power: 100})Mater = undefined 코드를 추가하면 Mater 객체가 참조를 잃고 더이상 접근할 수 있는 방법이 없기 때문에 가비지 콜렉터에 의해 수집당한다가비지 콜렉터이런 모양을 가지고 있다New Space : From-space, To-spaceOld Space : Pointer Space, Data Space 대부분의 객체들은 그림 1번의 From-space에서 생성된다 From-spaced에서 객체가 가득차면 To-space에서 가비지 콜렉터를 실행하고 살아남은 객체들을 그림 2번의 To-space로 옮긴다 1~2번의 과정으로 To-space마저 가득차면 To-space에서 가비지 콜렉터를 실행하고 객체를 그림 3번의 Old Space로 옮긴다 Old Space까지 가득 찼다고 판단하면 V8은 메이저 가비지 콜렉터를 돌린다메이저 가비지 콜렉터의 알고리즘은 다음과 같은 단계를 거친다 마킹 현재 어떤 객체가 사용중인지 어떤 객체가 참조가 끊겨서 사용할 수 없는지를 판단한다 사용 중이거나 가능한 객체를 활성 상태로 마킹한다 스위핑 가비지 콜렉터가 힙을 순회하면서 1단계에서 마킹하지 않은 객체들의 메모리 주소를 기록한다 이제 이 객체들의 메모리 주소에는 다른 객체들이 들어갈 수 있다 압축 2단계가 끝난 후 모든 활성 객체들이 압축되어 메모리 공간의 효율을 높여 새 객체들의 할당 성능을 증가시킨다 메이저 GC는 앱을 잠시 멈추게하는데 이를 피하기 위해 다음과 같은 기술을 사용한다 인크리멘탈 GC(Incremental GC): GC는 여러 개의 인크리멘탈 단계로 수행된다. 동시 마킹(Concurrent marking): 마킹은 자바스크립트 메인 스레드에 영향을 주지 않고 다중 헬프 스레드를 사용해 동시에 수행된다. Write barrier는 헬퍼들이 동시에 마킹하는 동안 자바스크립트가 생성한 객체 간 참조를 추적하는 데 사용된다. 동시 스위핑/압축(Concurrent sweeping/compacting): 스위핑과 압축은 자바스크립트 메인 스레드에 영향을 주지 않고 헬퍼 스레드에서 동시에 수행된다. 레이지 스위핑(Lazy sweeping): 레이지 스위핑은 메모리가 필요할 때까지 페이지에서 가비지 삭제를 지연시킨다." }, { "title": "하드웨어 가속", "url": "/posts/%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4_%EA%B0%80%EC%86%8D/", "categories": "CS, Web", "tags": "Quiz, will-change, 하드웨어, 가속, Composite", "date": "2022-01-08 17:33:00 +0900", "snippet": "하드웨어 가속하드웨어 가속이란?브라우저가 페이지를 렌더링하는 과정 중 CSSOM과 DOM 트리를 합쳐서 렌더 트리를 만든 뒤, 렌더 트리를 참조해 화면에 나타낼 부분을 Render Layer를 만드는데 이 과정에서 CPU가 아닌 GPU를 이용해 paint될 레이어들을 Graphics Layer로 분리한다.CPU가 아닌 하드웨어를 사용하기 때문에 하드웨어 가속 또는 GPU를 사용하기 때문에 GPU 가속이라고도 부른다.가속 대상렌더 트리에서 다음과 같은 속성을 가지고 있으면 Graphics Layer로 넘어간다. CSS 3D Transform(translate3d, preserve-3d 등)이나 perspective 속성이 적용된 경우 &amp;lt;video&amp;gt; 또는 &amp;lt;canvas&amp;gt; 요소 CSS3 애니메이션함수나 CSS 필터 함수를 사용하는 경우 자식 요소가 레이어로 구성된 경우 z-index 값이 낮은 형제 요소가 레이어로 구성된 경우. 레이어로 구성된 요소의 위에 위치하면 해당 요소도 레이어로 구성된다.CPU에만 의존해서 렌더링하는 것 보다 비디오나 3D 같이 무거운 부분들은 GPU를 사용해 렌더링하면 성능향상의 이점을 얻을 수 있다.주의 사항하드웨어 가속을 이용하면 분명 성능이점을 얻을 수 있지만 페이지의 모든 컨텐츠를 Graphics Layer로 만드는 짓은 하지말자.구체적으로 다음과 같은 사항들을 유의해서 사용하면된다. 무분별한 하드웨어 가속은 오히려 브라우저를 느리게 한다. 요소에 하드웨어 가속 속성이 부여되면 즉시 대상 영역이 GPU에 업로드되며, 이때 업로드되는 영역이 크면 화면이 깜빡이는 현상이 발생될 수 있다. 요소에 하드웨어 가속 속성이 부여되면 레이어로 분리되며, 레이어는 변경되는 내용이 없는 한 요소를 GPU 메모리에 다시 업로드하지 않는다. 하드웨어 가속 속성을 사용한 요소의 내용이 변경되면 GPU 메모리가 갱신되므로 요소의 내용을 미리 변경한 다음 하드웨어 가속 속성을 부여한다. 성능이 낮은 기기에서 하드웨어 가속을 사용하면 오히려 성능 저하를 가져올 수 있다.will-change특정 요소에 의미없는 CSS 3D 속성( transform: translate3d(0, 0, 0) )을 주면 하드웨어 가속을 줄 수 있는데 이러한 방법은 무분별하게 Graphics Layer를 만들고 이 과정의 비용이 크기 때문에 되려 성능 저하를 가져올 수 있다.따라서 will-change옵션을 사용하면 되는데 이름만 보면 알 수 있듯이 미래에 바뀔 요소를 브라우저에게 미리 알려줘서 최적화를 준비할 수 있게 해주는 옵션이다.해당 요소에 앞으로 어떤 스타일 변화가 있을 수 있는지 명시해주면 된다.will-change: transform, opacity;주의 사항역시 남발하지 말것*,*::before,*::after { will-change: all;}모든 요소에 will-change를 페이지를 최적화하겠다는 생각이 기특한 코드이지만 전혀 이점을 가지지 못한다.브라우저는 이미 가능한 최적화를 시행하고 있으므로 우선 순위가 없는 최적화 코드를 집어넣어버려 오히려 리소스만 사용하는 나쁜 케이스다.브라우저도 준비가 필요하다will-change는 브라우저에게 변화가 있는 요소에 힌트를 줘서 최적화의 준비 시간을 준다고 했다.다음과 같이 호버 이벤트가 발생했을 때 will-change로 힌트를 주고 바로 애니메이션을 발생시키면 브라우저는 준비할 수가 없다….element:hover { will-change: transform; transition: transform 2s; transform: rotate(30deg) scale(1.5);}호버 후 클릭 이벤트로 애니메이션을 발생시킨다면?그정도면 브라우저에겐 충분한 시간이다..element { transition: transform 1s ease-out;}.element:hover { // 마우스를 올리면 힌트를 주고 will-change: transform;}.element:active { // 마우스를 클릭 할시 애니메이션 발생 transform: rotateY(180deg);}일회용, 재사용 will-changewill-change가 요소에 선언되어있으면 그 자체로 리소스를 잡아먹는다. 따라서 해당 요소가 한 번의 변화만 일으키는 일회성 변화를 가지고 있는 요소라면 변화가 일어난 후 자바스크립트로 will-change`속성을 부여하고/지워줄 것을 추천하고 있다.처음부터 유저와 잦은 상호작용으로 많은 변화가 일어나는 요소라면 그렇게 할 필요가 없이 css 스타일 시트에서 선언해도 좋다.합성(Composite)렌더링 과정을 공부해본 사람은 알겠지만 리렌더링 과정에서 가장 리소스를 적게 먹는 과정은 합성이다.위에서 살펴본 각각의 레이어들에서 페인트 과정을 거친 뒤, 컴포지터 스레드라고 하는 별도의 스레드에서 사용자에게 보여줄 웹 페이지를 합쳐 보여주는 것을 합성이라고 한다. 메인 스레드의 개입 없이 수행되기 때문에 이 과정은 스타일 계산 혹은 자바스크립트 실행을 기다릴 필요가 없어 부드러운 성능을 보여줄 수 있다.유저가 브라우저에서 스크롤을 내리게되면 컴포지터 스레드는 이미 페인트가 끝난 레이어들의 위치만 옮겨서 재합성한 뒤 다시 보여주면된다.이벤트 감지컴포지터 스레드는 분명 자바스크립트가 실행되는 메인 스레드와 다른 스레드다. 그럼 합성된 페이지 내에서 자바스크립트 이벤트가 발생하는 것을 컴포지터 스레드가 어떻게 감지할 수 있을까?결론부터 말하면 컴포지터 스레드는 이벤트가 달려있는 요소에 대해서 고속 스크롤 불가 영역(non-fast scrollable region)’으로 표시하고 이벤트가 발생하면 해당 이벤트에 대한 정보를 메인 스레드로 보내준다.고속 스크롤 불가 영역 외에서 이벤트가 발생하면 메인 스레드에 정보를 보낼 필요가 없기 때문에 컴포지터 스레드는 합성 과정을 진행한다.이벤트 위임하지만 고속 스크롤 불가 영역 내에서 이벤트가 발생하면 메인 스레드에 정보를 보내주어야하기 때문에 컴포지터 스레드는 메인 스레드에서 이벤트 처리가 끝날 때 까지 기다려야하는데 이벤트 위임과 이 상황이 겹치면 다음과 같은 일이 벌어진다.document.body.addEventListener(&#39;touchstart&#39;, event =&amp;gt; { if (event.target === area) { event.preventDefault(); }});페이지의 모든 영역이 고속 스크롤 불가 영역이 되어버려 부드러운 합성을 할 수 없는 상태가 되어버리는 것이를 방지하기 위해 메인 스레드의 응답을 기다리지 말고 새 프레임을 만들어도 된다고 명시해주는 옵션이 passive: true다.document.body.addEventListener(&#39;touchstart&#39;, event =&amp;gt; { if (event.target === area) { event.preventDefault() } }, {passive: true}); https://d2.naver.com/helloworld/2061385 https://d2.naver.com/helloworld/6204533 https://dev.opera.com/articles/ko/css-will-change-property/" }, { "title": "CORS", "url": "/posts/CORS/", "categories": "CS, Network", "tags": "Quiz, CORS", "date": "2022-01-07 14:19:00 +0900", "snippet": "corsSOP (Same Origin Policy)SOP(동일 출처 정책)는 동일한 Origin에서만 나온 리소스와 상호작용하도록 하는 정책이다.Origin?오리진이란 위 그림에서 알 수 있듯 URL 요소 중에 protocol와 host(hostname + port) 부분을 가르켜 origin이라고하는데 이 부분이 일치해야 동일한 출처 즉 Same Origin이라고 판단한다. 참고로 IE(Internet Explorer)브라우저에서는 동일 출처인지 판단할 때 port를 끼워서 판단하지 않고 protocol과 hostname만을 가지고 판단한다.보안을 위해서 동일한 origin에서 가져온 리소스만 사용한다는 것은 알겠는데 그럼 웹 개발을 할 때 origin에 있는 리소스가 필요한 상황에서는 어떻게 해야할까?CORS (Cross Origin Resource Sharing)CORS는 교차 출처 리소스 공유로 해석되며 추가 HTTP 헤더를 사용하여 다른 출처에서 가져온 리소스에 상호작용할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제이다.CORS는 각각 Preflight Request, Simple Request, Credentialed Request 의 3가지 접근제어 시나리오가 존재한다.Simple Request클라이언트에서 서버로 보내는 요청이 다음과 같은 조건을 만족하면 해당 요청은 Simple Request가 된다. 옵션 값 Method GET, HEAD, POST Headers Accept, Accept-Language, Content-Language, Content-Type (헤더의 옵션 중) Content-Type application/x-www-form-urlencoded, multipart/form-data, text/plain 위는 클라이언트의 요청이 Simple Request 로 제어될 경우의 흐름을 나타낸 그림이다. 이름처럼 단순하게 클라이언트에서 보낸 요청을 서버에서 받아 명시되어있는 Origin과 동일하면 클라이언트에게 응답을 보낸다.표를 보면 알 수 있듯이 우리가 일반적으로 웹을 개발하며 API로 통신할 때 Content-Type이 대부분 json인 것을 생각하면 Simple Request로 제어되는 경우는 거의 없다고 보면되고 대부분은 아래에서 설명할 Preflight Request로 제어된다.Preflight RequestPreflight Request는 OPTIONS 메서드를 가진 Preflight Request와 본 요청인 Main Request로 나뉘는데 Preflight Request를 보내서 해당 출처에서 서버와 상호작용 가능한지 확인하고 가능하다면 Main Request를 보내게된다.Preflight Request로 Origin, 실제 요청의 메서드, 실제 요청의 추가 헤더등을 담아서 보내면Preflight Response로 서버에서 허용하고있는 Origin들, 허용하는 메서드 허용하는 헤더, Preflight의 응답 캐시 기간(추후 같은 Preflight Request를 캐싱하는 기간)으로 응답한다.왜 Simple Request로 하지않고 굳이 Preflight Request로 한 번의 과정을 더 거치게 되는걸까?CORS 에러는 서버에서 내려주는 것이 아니라 서버에서 보낸 응답에 Allow-Origin을 보고 브라우저 단에서 발생시키는 에러다. 따라서 API 요청이 DB나 서버에 저장된 데이터를 변경시키는 요청일 경우 Preflight로 확인하지 않고 본 요청을 바로 보내게된다면 DB의 데이터는 수정되었지만 CORS 에러는 발생하는 상황이 발생한다.이런 상황을 방지하기 위해서 Preflight Request로 허가된 출처, 메서드 등인지를 확인하는 것Credentialed Request인증관련 헤더를 포함할 때 제어되는 흐름, 쿠키나 jwt를 클라이언트에서 헤더에 포함시켜서 서버로 보내고 싶을 때 Credential 옵션을 주어야하는데 클라이언트에서만 이 옵션을 설정하게되면 서버에서는 이 값을 볼 수가 없기 때문에 서버에서도 Allow-Credentials 옵션을 설정해주어야한다.Credentials 옵션을 설정할 때는 Allow-Origin 옵션에 와일드카드(*)를 사용할 수 없으니 주의하자.해결하기로컬일 경우 프론트 개발환경에서 webpack-server를 사용하고 있다면 프록시 설정을 해주어서 api 요청 서버를 속여서 cors 에러를 피해갈 수 있다.하지만 실배포 환경일 경우에는 백엔드에서 설정을 해주는게 보편적인데 express 같은 경우에는 cors 라이브러리를 설치해서 손쉽게 해결할 수 있다. https://velog.io/@minukang5874/URL-%EC%94%B9%EA%B3%A0-%EB%9C%AF%EA%B3%A0-%EB%A7%9B%EB%B3%B4%EA%B3%A0-%EC%A6%90%EA%B8%B0%EA%B8%B0" }, { "title": "HTTPS", "url": "/posts/HTTPS/", "categories": "CS, Network", "tags": "Quiz, HTTPS, CA, TSL, SSL", "date": "2022-01-06 17:29:00 +0900", "snippet": "HTTPSHTTP 프로토콜은 전송 정보가 암호회되지 않는 문제점을 가지고 있어서 클라이언트와 서버가 데이터를 주고 받을 때 해커의 공격으로부터 탈취당하기가 쉽다.이러한 보안상의 문제점을 극복하기 위해 나온것이 SSL(보안 소켓 계층)을 사용한 HTTPS(HyperText Transfer Protocol Secure)인데 주고받는 메세지와 헤더를 모두 암호화한다.SSL/TSLSSL은 Secure Sockets Layer의 약자로 웹 서버와 웹 브라우저간의 보안을 위해 만든 프로토콜이다.대칭키 방식과 공개키 방식을 혼합해서 사용한다.대칭키와 공개키 방법을 알아보자대칭키클라이언트가 비밀키를 가지고 평문을 암호화해서 서버로 보내면 서버에서 클라이언트와 동일한 비밀키를 가지고 암호문을 복호화해 해독하는 방식대칭키는 암호화/복호화가 쉽다는 장점을 가지고 있고 암호문을 전송하기 때문에 해커가 도중에 탈취해도 해당 정보를 알아볼 수 없다는 장점을 가지고 있다. 하지만 서버와 클라이언트가 동일한 키를 가지고 있기 위해서는 둘 중 한 곳에서 키를 전송해준 다음 암호화/복호화를 진행해야한다.이 키를 전송하는 과정에서 해커가 키를 가져가버리면 대칭키 암호화 방식은 말짱도로묵이되어버리는 단점이 있다.공개키평문 + 공개키 = 암호문, 암호문 + 비공개키 = 평문 으로만 암호/복호화가 가능한 방식클라이언트에서 평문을 공개키로 암호화해서 서버에 전달하면 서버는 비공개키를 가지고 있고 해독한다. 이 암호화 방식은 해커가 도중에 암호문을 가로채도 비밀키를 들고 있지 않으면 평문을 해독할 수 없기때문에 대칭키보다 보안적인 부분이서 이점이 있지만 암호화 연산 시간이 느리다는 단점도 가지고 있다.공개키와 대칭키의 서로의 장/단점을 보완하기 위해서 SSL은 이 둘을 혼합한 방식을 사용한다.HTTPS 통신과정HTTPS는 HTTP와는 다르게 통신전에 TSL handshake라는 과정을 거치는데 TCP 3-way handshake와는 별도의 과정이다. 클라이언트가 client hello를 보낸다. 이때 임의의 난수와 각종 정보들을 같이 실어서 보낸다. server hello로 클라이언트에게 응답한다. 이때 서버의 공개키, 서버 난수, 각종 정보가 담긴 담긴 인증서를 보낸다. 인증서 또한 제 3의 인증기관(CA)의 비밀키로 암호화되어있다. 클라이언트는 받은 인증서를 CA에서 받은 공개키로 복호화해서 유효한 인증서인지 확인한다. 이 때 거짓된 인증서라면 경고를 보낸다. 인증서에 담긴 1과 2에서 생성한 난수를 적절히 조합해 대칭키로 등록한 뒤 마찬가지로 인증서에 담겨있던 서버의 공개키로 암호화하고 서버로 전송한다. 해당 난수 조합을 서버의 비밀키로 복호화하고 대칭키로 등록한다. 악수를 종료하고 4,5에서 만든 대칭키로 암호화 복호화하며 통신한다. https://ichi.pro/ko/amhohwa-jeongbo-boan-gisul-234313939662355 https://parksb.github.io/article/24.html" }, { "title": "HTTP", "url": "/posts/HTTP/", "categories": "CS, Network", "tags": "Quiz, HTTP, QUIC", "date": "2022-01-05 19:16:00 +0900", "snippet": "HTTPHTTPHyperText Transfer Protocol웹에서 이루어지는 모든 데이터 교환의 기초로 HTML 문서와 같은 리소스를 가져올 수 있도록 해주는 클라이언트 - 서버 프로토콜이다.HTTP의 특징http는 크게 무상태성과 비연결성 두 가지 특징을 가지고 있다.1. 무상태성서버가 클라이언트를 식별할 수 있게 해주는 것을 상태라고 부른다.위에서 말했듯이 http는 상태를 가지지 않는 무상태라고 이야기했는데 그럼 HTTP 요청을 받을 때 서버는 요청의 주체가 누구인지를 모른다는 것을 뜻한다. 이는 곧 요청을 신뢰할 수 없다는 말과 동일하며 매번 요청이 들어올 때 마다 인증 과정을 거쳐야한다. 사이트에 접속 로그인 마이 페이지 로그인 …이대로 서비스하는 것은 말도 안되게 비효율적이며, 이를 해결하기 위해서 몇가지 방법이 존재한다상태를 기억하는 방법1. 쿠키set-cookie를 이용해 브라우저 쿠키에 사용자 정보를 저장하고, HTTP 쿠키 헤더에 담아서 요청이 오갈 때 서버에서 쿠키를 조회해 클라이언트를 식별할 수 있게 하는 방법2. 세션브라우저에 저장되어있는 사용자 정보는 해커의 공격으로부터 취약하다.그래서 이를 보완하기 위해 사용자 정보를 서버에다 저장하는 방법이 나왔는데 이것이 세션이다. 사용자가 로그인하면 데이터베이스에서 일치하는지 확인하고 세션 정보를 만들어둔 뒤 클라이언트에게 넘겨준다. 그럼 쿠키와는 다르게 사용자 정보 대신 세션 정보를 브라우저에 저장하고 쿠키 헤더에 세션 정보를 담아서 서버에 요청한다. 요청을 받은 서버는 3에서 만든 세션 정보와 일치하는지 확인한다.이런 세션을 이용한 상태 저장 방법은 서버에 로그인한 유저의 상태를 전부 저장하기 때문에 동시 접속자가 많아질수록 서버에서 부담해야하는 리소스가 커진다는 단점이 있다3. 토큰로그인시에 정보가 일치하면 토큰화해서 클라이언트에 넘겨주는 방법클라이언트는 받은 토큰을 저장해서 요청하는데 세션과는 다르게 서버에서는 요청시에 받은 토큰을 복호화해서 유효한지 확인만하면 된다.그래서 서버에서는 따로 상태를 저장할 필요가 없어 부담이 덜하다.비연결성비연결성은 클라이언트와 서버가 연결되어있지 않는 상태를 말한다HTTP는 TCP/IP를 기반으로 만들어진 프로토콜이고 TCP/IP는 3-way-handshake를 시작으로 하는 연결지향적 프로토콜이다. 그런데 어째서 TCP/IP를 기반으로하는 HTTP는 비연결성을 띠고 있는 것일까?실제로 HTTP는 자원을 효율적으로 사용하기위해 데이터를 주고 받을 때 서버와 클라리언트가 연결되고 데이터 교환이 끝나면 연결을 끊는 비지속연결 통신으로 비연결성의 특징을을 띤다.비지속연결 HTTP보통 브라우저가 요청을 보내서 받아오게 되는 페이지는 HTML, CSS, JS, 이미지, 영상.. 등등 여러 파일을 받아와서 사용자에게 보여주어야한다.그렇다는 말은 HTTP로 필요한 파일들을 받아올 때 하나의 파일을 받고 연결을 끊고 다시 받아오고 연결을 끊고.. 를 반복해야하는데 TCP/IP 를 기반으로 만들어진 프로토콜인만큼 연결 마다 3-way handshake가 발생하게 되고 이 연결 수가 늘어날수록 지연시간이 늘어나 비효율적인 통신이 되어버린다.지속연결 HTTP위의 단점을 개선하고자해서 나온 방법이 지속 연결 HTTP인데 자원을 요청했을 때 묶여있는 모든 자원을 받아올 때까지 연결을 유지하고 있는 것을 말한다.HTTP 1.0 버전에서는 헤더에 Keep-Alive 옵션을 주면 지속 연결이 가능하다.HTTP 1.1누가 봐도 Keep-Alive 옵션을 주는 것이 통신 효율이 좋아보인다. 이를 똑똑한 사람들이 모를리 없을테니 조금 더 발전된 버전인 1.1버전에서는 해당 옵션을 명시하지 않을 경우 기본 값으로 모든 연결이 지속 연결로 처리된다.Pipelining또 통신 시간을 단축하기 위해 pipelining이라는 기술을 도입했는데이전의 통신 방법은 클라이언트가 보낸 요청에 의해 응답이 오기 전까지 다른 요청을 보내지 못했지만 pipelining을 도입함으로써 클라이언트는 일단 요청을 마구 보내놓고 순서대로 서버에게서 응답을 받아 대기 시간을 단축시키는 방법이다.Head Of Line Blocking이 pipelining도 문제점이 있었는데 클라이언트의 첫 요청이 시간이 오래 걸리거나, 문제가 생겼을 경우 두 번째 요청이 아무리 빠르게 응답할 수 있는 요청이어도 응답할 수 없는 현상. 이 때문에 전체적인 응답 시간이 지연된다.다중 TCP 연결TCP는 하나의 연결에 하나의 응답만 전달받을 수 있도록 보장되기 때문에 여러개의 응답을 병렬적으로 받기 위해서 서버와 여러개의 TCP 통신을 연결한다.이러한 다중 연결은 HOL를 불러오고 TCP 연결의 비효율적인 사용을 초래한다.HTTP 2.01.1에서 성능을 항샹 버전바이너리 프레이밍 계층기존 1.1 버전에서는 Plain Text를 사용하고 개행을 통해 헤더와 본문을 구분했다면 2.0에서는 바이너리 포맷으로 인코딩된 메시지와 프레임으로 구성된다.이를 이용함으로써 파싱, 전송속도가 빨라지게 됐다.멀티 플렉싱2.0에서는 프레임으로 구성된 메시지를 하나의 커넥션에서 여러개의 스트림으로 다중 전송이 가능해졌다.덕분에 비효율적인 TCP연결 부분이 해결되었으며 각 프레임마다 식별자를 가지고 있어서 꼭 순서대로 응답이 돌아오지 않아도 되게 되었고 따라서 HOL문제가 해결됐다.TCP 자체의 문제하지만 http 2.0의 스트림을 이용한 통신도 TCP 프로토콜을 사용하기 때문에 TCP 자체에 있는 HOL의 문제는 해결할 수가 없다.스트림 우선순위 지정순서대로 오지 않는 응답 프레임에 따라서 클라이언트가 우선순위 지정 트리를 구성하고 통신할 수 있다. 이 트리는 클라이언트가 선호하는 응답 수신 방식을 나타내며 서버에서 이 트리 정보를 사용해서 스트림 처리의 우선순위를 지정해 높은 순위에 따라 클라리언트에게 최적으로 전달하도록 대역폭을 할당한다.서버 푸시클라이언트가 요청하지 않은 정보에 대해서 서버가 알아서 데이터를 보내주는 것.index.html에서 참조하고 있는 css나 js 파일들이 있다면 클라이언트가 index.html만 요청하고 나머지 파일들을 요청하지 않아도 어짜피 필요할 것이라 판단하고 서버측에서 css와 js파일을 자체적으로 보낸다.헤더 압축static dynamic table을 이용하여 중복되는 정보는 table의 인덱스만 남기고 중복되지 않은 정보는 Huffman 인코딩을 하여 헤더를 압축해서 요청할 때 마다 중복되는 헤더를 줄여서 헤더를 압축해 헤더의 크기를 최대 85%까지 줄였다.QUIC2.0의 문제를 탈피하기 위해서 UDP를 기반으로 통신하는 프로토콜왜 UDP인가?TCP는 신뢰성을 확보하기 위해 이미 너무 많은 기능들이 들어가있어서 그 자체를 손보기 힘들다고 판단해서 새하얀 백지같은 UDP에다가 개발자가 신뢰성을 불어넣으면서 지연 시간을 더 줄일 수 있다.구글은 데이터 전송의 신뢰성을 어플리케이션 계층에 구현했고 따라서 3-way handshake를 사용할 필요가 없다.향상된 멀티 플렉싱2.0은 하나의 TCP 연결 내부에서 스트림 통신을 하기 때문에 HOL를 근본적으로 해결할 수 없었지만 QUIC은 스트림 자체가 여러개이기 때문에 하나의 스트림에서 병목현상이 생기더라도 다른 스트림에 영향을 주지 않는다. https://victorydntmd.tistory.com/286 https://jins-dev.tistory.com/entry/HTTP11-%EC%9D%98-HTTP-Pipelining-%EA%B3%BC-Persistent-Connection-%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC https://developers.google.com/web/fundamentals/performance/http2?hl=ko" }, { "title": "01.Type", "url": "/posts/Type/", "categories": "JavaScript, you don't know js", "tags": "Quiz, type, typeof, undefined", "date": "2022-01-04 17:42:00 +0900", "snippet": "타입내장 타입자바스크립트에는 다음 7가지 내장 타입이 존재한다. null undefined number string boolean object symbol이 중 object를 제외한 나머지 타입들은 원시 타입이라고 부른다.typeof이러한 타입들은 typeof연산자를 사용해서 알 수 있는데 놀랍게도 typeof의 반환값이 항상 위에서 언급한 7가지 타입에 1:1로 대응되지 않는다.console.log(typeof undefined); // undefinedconsole.log(typeof true); // booleanconsole.log(typeof 1); // numberconsole.log(typeof &#39;2&#39;); // stringconsole.log(typeof {}); // objectconsole.log(typeof Symbol()); // symbolconsole.log(typeof null); // object...?다른 친구들은 다 자신의 타입 명칭과 동일한 문자열을 내뱉는데 null은 혼자서 object를 반환하고 있다.이는 버그이지만.. 너무 오랫동안 방치되어온 버그라 해결될 가능성이 거의 없다고 한다.그래서 null값을 정확히 확인하려면 다음과 같이 비교하여야한다.const a = null;console.log(!a &amp;amp;&amp;amp; typeof a === &#39;object&#39;); // true비교하려는 값이 falsy한 값인데 typeof로 object를 반환하고 있다면 그 값은 null임을 확인하는 조건1대1 대응되지 않는 이유는 한가지가 더 존재하는데const a = () =&amp;gt; {};console.log(typeof a); // functiontypeof로 함수를 판별할 경우 7가지 타입에 존재하지 않는 function이라는 문자열을 반환한다.그렇다면 function은 7가지 타입에 더불어 존재하는 최상위 내장 타입 중 하나여야하는게 아닐까..하는 의문이 들지만 실제로는 object의 하위 타입이다.이처럼 함수는 호출 가능한 객체이며 내부프로퍼티로 call 메서드를 호출할 수 있는 객체를 함수라고 정의하고 있다.undefined vs undeclaredundefined은 값이 없음을 나타낸다. 그렇다면 초기화 되지 않은 변수도 값이 없는 것이니 undefined일까?let a;console.log(a); // undefinedconsole.log(b); // Error: b is not defined자바스크립트는 선언되었지만 값이 할당되지 않은 변수에 undefined를 내뱉고 있지만 아예 선언조차 되지 않은 무언가에 대해서는 is not defined라는 에러를 뱉는다.is not defined라니.. 결국 undefined이라는 소리 아닌가 싶은데.. 명확하지 않다고 생각할 수 있지만 에러를 뱉는 점에서 다르니까 넘어가자문제는 선언되지 않은 변수에 typeof를 사용했을 때다.console.log(typeof a); // undefinedconsole.log(typeof b); // undefined놀랍게도 둘 다 undefined라는 결과가 나오는데 자바스크립트는 값이 없는 변수와 선언되지 않은 변수 모드 undefined로 처리한다." }, { "title": "Web Worker", "url": "/posts/Web_Worker/", "categories": "JavaScript, Quiz", "tags": "Quiz, WebWorker", "date": "2022-01-03 22:46:00 +0900", "snippet": "Web Worker익히 알다시피 자바스크립트는 싱글 스레드이며 그 자체로는 써먹기 힘들기 때문에 V8, node 엔진 등을 이용해서 비동기를 이용해 그 문제점을 어느정도 극복하고 있다.비동기 작업의 한계하지만 그러한 비동기 작업들도 만능은 아니다. 다음과 같은 일을 할 경우 메인 스레드가 block되면서 원활한 작업이 이루어지지 않게된다.• 매우 많은 문자열의 Encoding/Decoding• 복잡한 수학 계산(소수prime numbers, 암호화 등)• 매우 큰 배열의 정렬• 네트워크를 통한 데이터 처리• local storage 데이터 처리• 이미지 처리• 비디오나 오디오 데이터 처리• Background I/O• 기타 백그라운드에서 오랜 시간 작업해야 하는 경우• UI 스레드를 방해하지 않거나 방해받지 않고 지속적으로 수행해야 하는 작업이렇게 메인 스레드가 block될 정도의 일들은 web worker에게 맡겨서 멀티 스레딩의 이점을 누릴 수 있다.사용 예시워커를 사용하기 위해서는 새로운 파일을 생성하고 다음과 같이 사용해야한다.// in main.jsif(&#39;Worker&#39; in window){ // 웹 워커를 지원하는지 확인하는 조건문 const worker = new Worker(&#39;./worker.js&#39;); }이렇게 워커를 생성하면 worker.js파일에 있는 코드가 실행된다.// in worker.js오랜 시간이 걸리는 어떤 작업.그렇다면 이 워커는 정말 멀티 스레드 프로그래밍처럼 자원과 스코프를 공유하고 그에 따른 부담을 개발자가 해결해야할까?“정답은 그렇지 않다”이다. 워커들은 워커 인스턴스를 생성한 부모와 자원을 공유하지 않는다.대신 worker로 생성한 스레드의 통신은 다음과 같이 onmessage 리스너, postMessage 메서드를 통해서 할 수 있다.// in main.jsif(&#39;Worker&#39; in window){ // 웹 워커를 지원하는지 확인하는 조건문 const worker = new Worker(&#39;./worker.js&#39;); worker.postMessage(&#39;worker에게 보낼 메시지&#39;); worker.onmessage = (message) =&amp;gt; { // 워커에서 보낸 메시지를 받고 작업 수행 worker.terminate();// 워커 종료 }}// in worker.jsself.onmessage = (message) =&amp;gt; { // 메인 스레드에서 받은 message를 받아서 작업 수행 postMessage(&#39;작업 후 메인 스레드에 보낼 메시지&#39;);}보는 바와 같이 메시징 구조는 완벽하게 대칭적이다.워커 파일 내부에서 특이하게 자신을 가르킬 때 this를 사용하게 되면 호출 주체에 따라 this가 바뀌게 됨으로 워커의 셀프 바인딩은 self를 이용하는 것을 권장하고 있다. https://darrengwon.tistory.com/1171" }, { "title": "iterator", "url": "/posts/iterator/", "categories": "JavaScript, Quiz", "tags": "Quiz, iterator, iterable, surrogates", "date": "2021-12-20 15:36:00 +0900", "snippet": "Iterator이터레이터를 알기 전에 용어를 간단하게 정리하고 가자iteratornext() 메서드를 가지고 있는 객체로 [Symbol.iterator]에 의해 생성된다.next()메서드는 반드시 {done: boolean [, value: any]} 꼴의 객체를 반환해야한다.iterable반복 가능한 이라는 뜻을 나타내며 iterator객체를 반환할 수 있는 [Symbol.iterator] 를 가지고 있는 객체를 iterable객체라고 한다.자바스크립트 내장 iterable객체는 다음과 같다.자바스크립트 내장 iterable객체는 다음과 같다. Array Set Map DOM NodeList primitive string정리해보면 위의 다섯 친구들은 [Symbol.iterator]메서드를 호출할 수 있고, [Symbol.iterator]메서드를 호출하면 next()메서드를 가지고 있는 iterator객체가 반환된다.const arr = [1,2,3];const iterator = arr[Symbol.iterator]();console.log(iterator);for…of눈치 챈 사람도 있겠지만 위에서 언급한 반복가능한 객체들은 for...of 으로 순회가 가능하다. 아무 생각 없이 써왔던 for...of는 iterable 객체만 사용이 가능한 것이었다.for...of가 어떻게 iterable객체를 순회하는지 과정을 살펴보자 for...of가 시작되자마자 for...of는 iterable객체에서 [Symbol.iterator]를 호출한다. 이후 for...of는 1번에서 호출한 [Symbol.iterator]의 반환 객체인 iterator객체로 동작한다. for...of은 iterator객체의 next()메서드를 호출하고 {done: false [, value: any]}를 반환받는다 next()메서드의 반환값이 {done: true}일 때까지 반복한다.동작 과정만 살펴보면 for...of은 내장 iterable객체가 아니더라도 [Symbol.iterator]메서드만 가지고 있으면 작동할 것 같다.사실 [Symbol.iterator]를 가지고 있으면 이미 iterable객체이긴 하지만 중요한 것은 iterable 하지 않은 객체를 iterable하게 만들 수 있다는 것iterable하게 만들기const obj = { a: 1, b: 2, c: 3, d: 4,};for(let v of obj){ console.log(v);}// Uncaught TypeError: obj is not iterableobj는 iterable하지 않기 때문에 당연히 for...of를 쓸 수 없다.우리가 obj에 직접 [Symbol.iterator]를 생성해준다면 어떨까?const range = { from: 1, to: 5,};range[Symbol.iterator] = function (){ return { current: this.from, last: this.to, next(){ if(this.current &amp;lt;= this.last){ return {done: false, value: this.current++}; } else{ return {done: true}; } } }}for(let v of range){ console.log(v); // 1, 2, 3, 4, 5}from부터 to까지 순차적으로 증가하는 iterator를 반환하는 [Symbol.iterator]메서드를 생성해주면 for...of가 잘 돌아가는 것을 확인할 수 있다.서로게이트 페어자바스크립트로 문자열을 역순으로 뒤집다보면 다음과 같은 상황을 마주할 수 있다.const str = &#39;𝒳😂&#39;; const reversedStr = str.split(&#39;&#39;).reverse();console.log(reversedStr); // �💳�UTF-16로 표현할 수 없는 문자들을 두 개의 16비트 한 쌍으로 표현하는 써로게이트 페어 문자를 마주할 경우 이런 일이 발생한다.&#39;𝒳&#39; === &#39;\\uD835\\uDCB3&#39;&#39;😂&#39; === &#39;\\uD83D\\uDE02&#39;사실은 이런식으로 표현되어있기 때문에 split을 사용해서 뒤집을 경우 16비트 단위로 잘려 원래 페어를 찾을 수 없기 때문에 형태를 유지하지 못하고 괴문자가 나오게되는 것이 경우 쉽게 문자열을 뒤집을 수 있는 방법이 존재하는데 Array.from()을 이용하는 것이다.Array.from()const str = &#39;𝒳😂&#39;;const reversedStr = Array.from(str).reverse().join(&#39;&#39;);console.log(reversedStr); // 😂𝒳Array.from은 16비트 단위로 끊어서 배열을 만드는 것이 아니라 유사 배열 객체와 iterable 객체를 진짜 배열로 만들어준다.문자열은 iterable 객체이기 때문에 iterator를 이용해 문자열을 잘라서 배열을 만드는 것이 아닌 next()가 반환하는 값으로 배열을 만들기 때문에 정상적인 문자열 뒤집기가 가능하다.split 메서드에 비해 속도는 느리다고 하니 참고.유사 배열 객체인덱스와 length 프로퍼티가 있는 객체를 유사 배열 객체라고 부른다.왜 인덱스와 length까지 있는 따로 추상화시킨 것일까? 그냥 배열을 사용하면 안되는 걸까?스택오버플로우에 나와 같은 궁금증을 가진 사람이 존재하긴했지만.. 딱히 시원한 대답을 얻지는 못했다개인적인 생각으로는 유사 배열은 배열에 있는 메서드를 따로 사용할 필요가 없어서 인 것 같다.대표적인 유사 배열에는 arguments나 querySelectorAll로 가져온 nodes등이 있는데 이 친구들은 데이터를 그냥 담은 컨테이너 자체일 뿐이다. 이를 배열로 표현한다면 불필요한 push나 pop 등등의 메서드들이 들어가게 되는데 이를 방지하기 위함이 아닌가..싶다. Javascript의 Iterator와 Generator iterable 객체" }, { "title": "Get, Post, Cache", "url": "/posts/Get_Post_and_Cache/", "categories": "CS, Network", "tags": "Quiz, http, get, post, cache", "date": "2021-12-19 22:01:00 +0900", "snippet": "GET vs POSTGET정보를 조회하기 위해 설계된 메서드GET은 정보를 요청할 때 body에 값을 담을 수 없으며 필요하다면 qeuryString을 이용할 수 있다.POST리소스를 생성/변경하기 위해 설계된 메서드POST는 리소스를 변경해야하기 때문에 body에 값을 담아서 전송해야한다(필수)queryString을 사용하지 않기 때문에 URL에 정보가 담기지 않아 GET보다는 보안적인 측면에서 나으나 보려고하면 얼마든지 볼 수 있기 때문에 민감한 정보라면 암호화해서 보내야한다.멱등성?결론부터 말하면 GET은 멱등하며 POST는 멱등하지 않다.멱등하다는 것은 동일한 연산에 대해서 항상 동일한 결과를 나타내는 것을 말하며 서버로 GET요청을 하면 항상 같은 응답값이 돌아와야한다는 것을 얘기한다.이러한 특성 때문에 동일한 GET요청은 캐싱될 수 있다.반대로 POST는 멱등하지 않으며 생성, 삭제, 수정의 생성과 변경이 가능한 메서드이기 때문에 항상 같은 응답값이 돌아온다고 보장되지 않는다.번외) POST vs PUT vs PATCH주로 POST는 생성에 PUT과 PATCH는 수정에 사용한다.POST는 리소스의 생성을 담당하고 있기 때문에 요청시마다 새로운 리소스를 반환한다. 그래서 위에서 멱등하지 않다고 얘기했다.POST /student{ “name”: “뽀로로”, “grade”: 1}PUT과 PATCH는 이미 존재하고 있는 리소스의 변경을 담당하고 있다. 그래서 요청 메세지를 보내는 것에서 차이가 난다.PUT /student/3{ “name”: ”에디” “grade”: 2}POST는 생성이기 때문에 그냥 메세지를 날리면되지만 PUT은 이미 존재하는 리소스의 id값을 같이 넣어서 요청해야한다.PUT 요청은 반복해서 보내도 같은 리소스에 대한 요청을 반복하기 때문에 같은 반환값이 돌아오게 된다. 따라서 멱등성을 만족한다.PUT vs PATCH그렇다면 PUT 과 PATCH는 둘 다 수정인데 무엇이 다를까PUT은 변경될 데이터 전체를 다 보내주어야한다.{ // 요청 전 “name”: ”에디” “grade”: 1}// 요청PUT /student/3{ “name”: ”에디1”}{ // 요청 후 “name”: ”에디1”, &quot;grade&quot;: null}위 처럼 변경하고자 하는 데이터만 담아서 보내버리면 나머지 데이터는 null로 변경되어버린다.{ // 요청 전 “name”: ”에디” “grade”: 1}// 요청PATCH /student/3{ “name”: ”에디1”}{ // 요청 후 “name”: ”에디1”, &quot;grade&quot;: 1}반면에 PATCH는 일부 데이터만 보낼경우 해당되는 데이터만 변경되고 나머지는 기존의 데이터를 가져다 쓴다.Cache?그렇다면 캐시는 무엇일까주어진 리소스의 복사본을 저장하고 있다가 요청이 들어오면 그걸 그대로 돌려주는 기술.서버에 부담을 줄일 수 있고 클라이언트에는 응답시간을 줄여주는 성능 향상을 보일 수 있다.하지만 리소스가 불변한 성질이 아니라면 계속해서 리소스가 변했음에도 같은 리소스를 응답하는 문제가 있을 수 있다.캐시는 두 가지로 분류할 수 있다사설 브라우저 캐시브라우저에 달려있는 캐시다. 컨텐츠를 캐싱해서 보여주고 뒤로가기나 앞으로가기 등에 사용된다공유 프록시 캐시브라우저에 달려있는 캐시는 개개인의 브라우저에서 캐싱하는 것이지만 공유 프록시 캐시는 다사용자의 요청 자체를 캐싱하는 서버같은 것캐시 제어HTTP 헤더에는 캐시 정책을 정의할 수 있는 Cache-control헤더가 존재한다 Cache-Control: no-store캐시를 허용하지 않는 것. 요청은 서버로 전송되고 전체 응답은 매번 다운로드 된다. Cache-Control: no-cache이름만 보면 캐시하지 않는 것 같지만 캐시를 하긴 한다. 대신 사용자에게 전달하기 전에 유효성 확인을 위해 서버로 요청을 보낸다.근데 이 경우 캐시의 역할을 할 수 있는가? 더 리소스를 잡아먹는 건 아닌지 궁금. Cache-Control: public or privatepublic은 프록시서버에 캐시 저장 허용, private는 브라우저단에만 허용 Cache-Control: max-age=«second&amp;gt;second&amp;gt;리소스가 유효하다고 판단되는 최대 시간을 설정해서 그 시간 만큼 캐싱하는 것변경되지 않을 파일에 대해 아주 긴 시간을 캐싱하도록 설정할 수 있다. Ex) 이미지, css, js, 정적파일들유효성리소서는 캐싱되고나면 사실 영원히 저장되어 요청에 반응할 수 있다. 하지만 유한한 저장공간을 가지고 있기 때문에 주기적으로 스토리지에서 제거되는데 이러한 과정을 캐시 축출이라고 부른다.만료된 리소스를 실효(stale)상태에 있게되는데 이 실효된 리소스는 바로 축출되거나 무시되지 않고 이 리소스에 대한 요청이 들어올 경우 이 리소스가 유효한지 아닌지를 확인하기 위해서 서버에 요청을 전달하고 서버는 본문을 전송하지 않고 304(Not Modified)를 보내서 대역폭을 절약한다.Expires나 max-age로 캐시 기간이 설정되어있지 않다면 Last-Modified 헤더를 찾아서 휴리스틱으로 유효 기간을 추정한다 https://hongsii.github.io/2017/08/02/what-is-the-difference-get-and-post/ https://developer.mozilla.org/ko/docs/Web/HTTP/Caching" }, { "title": "var, let, const, 호이스팅", "url": "/posts/variable_hoisting/", "categories": "JavaScript, Quiz", "tags": "Quiz, hoisting, TDZ", "date": "2021-12-18 17:56:00 +0900", "snippet": "var, let, constvarvar은 요즘은 잘 쓰이고 있지 않지만 그래도 간단하게 짚고 넘어가자함수 레벨의 스코프를 가지고 있으며 중복 선언이 가능하고 키워드의 생략이 가능하다문제점 중복 선언중복 선언이 가능하기 때문에 프로그래머가 같은 변수명으로 초기화할 수 있는 문제가 생긴다.var test = 1;var test = 3;console.log(test); // 3에러가 나지 않고 3이 정상적으로 출력되고 있다. 비정상적이라고 해야 맞는 것 같은데..자바스크립트를 배우는 초기에는 그렇구나~하고 넘어갔었는데 다시 보니까 경악스럽다. for문var의 문제점을 지적하며 흔히 볼 수 있는 예제for(var i = 0; i &amp;lt; 10; i++){ // something}console.log(i); // 10;for문에서만 사용하는 변수 i가 전역적으로 선언되어서 for문이 끝나고 나서도 유효한 것을 볼 수 있다.다음도 흔히 볼 수 있는 setTimeout과 같이 쓰는 예제for (var i = 0; i &amp;lt; 10; i++) { setTimeout(() =&amp;gt; { console.log(i); // 10, 10, 10, 10, 10, .. }, (i + 1) * 1000);}이 코드는 콜 스택에서 for문을 다 돌아버린 후에 setTimeout의 콜백 함수가 실행되기 때문에 로그로 찍어내는 전역 변수 i의 값은 전부 10으로 찍혀서 나오게 된다.이러한 문제들을 해결해주는 것이 let, const이다.let, constvar과 다른 점을 살펴보자let test = &#39;test1&#39;;let test = &#39;test2&#39;;const test = &#39;test1&#39;;const test = &#39;test2&#39;;둘 다 될리가 없다.for문for (let i = 0; i &amp;lt; 10; i++) { setTimeout(() =&amp;gt; { console.log(i); // 0, 1, 2, 3, 4, ... }, (i + 1) * 1000);}var 대신 let을 쓰면 정상적으로 출력이 되는데 함수 레벨의 스코프를 가지고 있는 var와 달리 let은 블록 레벨의 스코프이기 때문에 10번 반복되는 for문 안에서 i가 0부터 10일 때 까지의 스코프가 만들어지고 그 스코프를 각각 참조하는 클로저 setTimeout이 만들어진다.호이스팅자바스크립트 엔진은 실행 흐름 과정은 이러하다.코드 실행 -&amp;gt; 코드 평가 -&amp;gt; 런타임우리가 여기서 살펴볼 것은 코드 평가 단계인데 이 단계에서는 자바스크립트 엔진이 코드를 한 번 훑어보면서 선언문이란 선언문은 모두 최상단으로 끌어올리는데 이를 호이스팅이라고 부른다.console.log(a);console.log(b);console.log(test1);console.log(test2);var a = &#39;a&#39;;var b = &#39;b&#39;;function test1(){ console.log(&quot;this is test1&quot;);}var test2 = function(){ console.log(&quot;this is test2&quot;);}이 코드는 오류가 나야할 것 같지만 코드 평가 단계를 거치면서 다음과 같이 바뀌기 때문에 에러가 나지 않게된다.여기서 잠깐 변수 선언이 어떤 단계를 거쳐서 이루어지는지 살펴보자자바스크립트의 변수 선언 3단계자바스크립트는 변수를 선언할 때 선언, 초기화, 할당 3가지의 단계를 거치게 되는데 호이스팅되어 끌어올려질 때 var변수는 선언과 초기화 단계를 거치게되고 이후 런타임시에서 할당 단계를 거치게 된다.그래서 위의 코드는 호이스팅을 거치면서 선언과 초기화가 진행되어 아래와 같은 형태를 띠게된다var a; // &quot;= undefined&quot; 생략var b; // &quot;= undefined&quot; 생략var test2; // &quot;= undefined&quot; 생략function test1(){ console.log(&quot;this is test1&quot;);}// 여기까지 변수 선언과 변수가 undefined로 초기화가 이루어짐console.log(a); // undefinedconsole.log(b); // undefinedconsole.log(test1); // this is test1console.log(test2); // undefineda = &#39;a&#39;;b = &#39;b&#39;;test2 = function(){ console.log(&quot;this is test2&quot;);}변수 선언, 함수 선언문은 모두 위로 올라가고 할당은 런타임 과정에서 다시 이루어지게된다.이러한 메커니즘을 가지고 있기 때문에 콘솔 로그로 찍었을 때 에러가 나지않고 undefined를 뱉어내는 것예시에서는 var를 이용해서 호이스팅을 설명했는데 let과 const는 다를까?let과 const의 경우일단 코드로 실험부터 해보자console.log(test);let test = &#39;1&#39;;console.log(test);const test = &#39;1&#39;;호이스팅이 일어나지 않는다면console.log(test);위 코드를 실행시켰을 때 일어나는 is not defined 에러와 동일한 발생해야할 것이다. 하지만 실제로 발생하는 에러는 Uncaught ReferenceError: Cannot access &#39;test&#39; before initialization로 test 변수가 초기화되기 전에는 접근할 수 없다는 에러를 뱉고 있다. test의 존재를 알고 있는 것을 보니 호이스팅은 되는 듯 하다.var는 선언과 undefined초기화가 같이 이루어져서 에러가 발생하는 대신 undefined를 뱉었는데 let과 const는 그렇지 않다.let, const의 변수 선언 과정그림을 보면 알 수 있듯이 선언과 초기화 단계가 따로 이루어져있다 이 때 변수가 선언되고 나서 초기화 될 때까지의 구간을 Temporal Dead Zone(TDZ)라고 부른다.참고로 함수 선언문은 선언, 초기화, 할당이 동시에 이루어진다. https://noogoonaa.tistory.com/78 https://yceffort.kr/2020/05/var-let-const-hoisting" }, { "title": "자바스크립트의 Object", "url": "/posts/Object/", "categories": "JavaScript, Quiz", "tags": "Quiz, Object, create, assign, defineProperty", "date": "2021-12-16 01:46:00 +0900", "snippet": "원래는 부트캠프 막바지에 마스터님께서 퀴즈로 내어주신 Object.create의 역할은 무엇인가요?에 대해서 포스팅하려고 했는데 찾아보니 분량이 너무 적은 것 같아서 Object를 전반적으로 포스팅하려고 한다.Object객체 생성하기자바스크립트에서 객체를 만드는 방법은 다음과 같다. 생성자를 사용한 생성 방법 const obj = new Object({a:1}) 객체 리터럴을 이용한 생성 방법 const obj = {a:1} 두 방법 다 동일한 모양의 객체를 생성한다. Object.create()를 이용한 방법 아래에서 좀 더 자세히 살펴보자 Object.assign() 복사하려는 객체의 모든 열거 가능한 자체 속성을 복사해 대상 객체에 붙여넣습니다. 그 후 대상 객체를 반환합니다.여기서 열거 가능한 자체 속성이란 for...in으로 불러올 수 있는 프로퍼티 중 프로토타입 체인을 확인하지 않고 자신만의 직접적인 프로퍼티를 말한다.const target = { a: 1, b: 2 };const source = { b: 4, c: 5 };const returnedTarget = Object.assign(target, source);//target : { a: 1, b: 4, c: 5 }//returnedTarget : { a: 1, b: 4, c: 5 }주의 사항assign은 깊은 복사일까? 얕은 복사일까?const obj1 = { a: 0 , b: { c: 0}};const obj2 = Object.assign({}, obj1);obj1.a = 3;// obj1 { a: 3 , b: { c: 0}};// obj2 { a: 0 , b: { c: 0}};객체를 그대로 복사해와서 obj1.a의 값을 변경했는데 obj2.a의 값이 변경되지 않았다.이 코드만 보면 assign은 깊은 복사인 것 같다. 다음 코드를 이어서 보자obj1.b.c = 3;// obj1 { a: 3 , b: { c: 3}};// obj2 { a: 0 , b: { c: 3}};만약 복사하는 프로퍼티가 객체에 대한 참조라면 참조값을 복사해오기 때문에 얕은 복사가된다.다음과 같이 JSON 메서드를 사용해서 깊은 복사를 할 수 있다.obj1 = { a: 0 , b: { c: 0}};const obj3 = JSON.parse(JSON.stringify(obj1));obj1.a = 4;obj1.b.c = 4;// obj1 { a: 4 , b: { c: 4}};// obj3 { a: 0 , b: { c: 0}};Object.create() 지정된 프로토타입 객체 및 속성(property)을 갖는 새 객체를 만듭니다.위에서 언급한 객체를 만드는 방법 중 하나이다.var a = {a: 1};// a ---&amp;gt; Object.prototype ---&amp;gt; nullvar b = Object.create(a);// b ---&amp;gt; a ---&amp;gt; Object.prototype ---&amp;gt; nullconsole.log(b.a); // 1 (상속됨)var c = Object.create(b);// c ---&amp;gt; b ---&amp;gt; a ---&amp;gt; Object.prototype ---&amp;gt; null프로토타입 체인을 이용해서 상속된 객체를 생성할 수 있다.순수 사전식 객체const obj = Object.create(null);// obj ---&amp;gt; null이런식으로 프로토타입이 없는 객체를 생성할 수도 있는데 이를 ‘아주 단순한(very plain)’ 혹은 ‘순수 사전식(pure dictionary)’ 객체라고 부르는데 Object나 {...}(리터럴) 방식으로 생성한 객체보다 훨씬 단순하다.이 순수 사전식 객체는 프로토타입으로 Object.prototype를 가지고 있지 않기 때문에 toString()과 같은 메서드를 사용할 수 없다. Object.create(null)을 사용하면 프로토타입이 없는 객체를 만들 수 있습니다. 이런 객체는 &quot;__proto__&quot;를 키로 사용해도 문제를 일으키지 않기 때문에 커스텀 사전을 만들 때 유용합니다.라고 하는데.. 개발하면서 객체의 key값으로 __proto__를 사용할 일이 있기나 할까 라는 의문이 든다.상속생성자 함수의 상속에 사용할 수도 있다.사람을 나타내는 Human 과 자식인 Student 생성자들이 있다고 가정하자.function Human(name) { this.name = name;}Human.prototype.sayName = function() { console.log(this.name);};Human은 sayName이라는 메서드를 가지고 있으며 인스턴스에 할당된 name을 출력한다.이제 Student 생성자 함수를 만들어보자function Student(name) { Human.call(this, ...arguments);}Student의 prototype을 Human prototype을 가르키게해서 sayName을 사용할 수 있게 해주자Student.prototype = Human.prototype;const human = new Human(&#39;human&#39;);const student = new Student(&#39;student&#39;);human.sayName(); // humanstudent.sayName(); // student잘 된 것 같지만 문제가 하나 있다Human의 prototype을 Student prototype에 그대로 초기화 해주었기 때문에 생성자 함수가 그대로 Human(name)인 것을 확인할 수 있다. Student prototype의 생성자를 다시 Student로 돌려주자Student.prototype.constructor = Student;이번엔 Human의 prototype 생성자 함수가 Student로 바뀌었다.. 이 지옥에서 벗어나기 위해서 사용하는 것이 Object.create()이다.function Human(name) { this.name = name;}Human.prototype.sayName = function() { console.log(this.name);};function Student(name) { Human.call(this, ...arguments);}Student.prototype = Object.create(Human.prototype);Student.prototype.constructor = Student;Object.defineProperty()이하 예전 블로그 복붙Object.defineProperty(객체, 프로퍼티, 설명) 정적 메서드는 객체에 직접 새로운 속성을 정의하거나 이미 존재하는 속성을 수정한 후, 그 객체를 반환한다MDN에 나와있는 정의.말이 어려운데 쉽게 설명하자면 객체 내부에 있는 프로퍼티에 설명을 따라서 해당하는 속성을 정의하거나 수정하고 다시 객체를 반환하는 Object의 정적 메서드이다const obj = {};Object.defineProperty(obj, &#39;value&#39;, { value:1000,}); // 이 때 반환값은 obj 객체console.log(obj); // {value: 1000}defineProperty 에서 설명은 보다시피 객체로 서술되며 데이터 서술자와, 접근자 서술자 두 가지 종류로 나뉘게 된다좀 더 자세한 설명들은 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty 에 나와있고내가 알아볼 것은 접근자 서술자이다접근자 서술자는 class의 setter와 getter를 일반 객체에서도 적용시켜주는 역할을 한다고 보면 된다먼저 익숙한 클래스의 setter와 getter를 살펴보자class Obj { constructor(a) { this.a = a; } get getA(){ console.log(&#39;get&#39;); return this.a; } set setA(nextValue){ console.log(&#39;set&#39;); this.a = nextValue; }}const obj = new Obj(&#39;test&#39;);obj.getA; // obj.a =&amp;gt; &#39;test&#39;// console log print &#39;get&#39;obj.setA = &#39;asdf&#39;; // obj.a =&amp;gt; &#39;asdf&#39;// console log print &#39;set&#39;클래스에서는 obj 내부의 값이 바뀔 때 무언가 로직을 추가해 줄 수 있다defineProperty 의 접근 서술자도 마찬가지다 클래스가 아닌 일반 객체 내부의 값을 수정, 접근할 때그 행동을 가로채서 내가 원하는 다른 로직을 끼워넣고 반환시킬 수 있게 해주는 get과 set을 설정할 수 있다const obj = {};Object.defineProperty(obj, &#39;a&#39;, { get(){ console.log(&#39;get&#39;); return this._a; }, set(nextValue){ console.log(&#39;set&#39;); this._a = nextValue; }});obj.a // obj.a =&amp;gt; undefined// console log print &#39;get&#39;obj.a = &#39;test&#39; // obj.a =&amp;gt; test// console log print &#39;set&#39;obj 객체의 a라는 프로퍼티에 대해서 get과 set을 설정하는 코드이다여기서 this._a 에 접근하는 코드에서 나는 헷갈림이 있었다 이해를 돕기위한 간단 설명을 해보자면(this 는 obj를 가르킨다)this.a에 바로 접근하게 코드를 수정했다고 생각하고 코드의 실행 과정을 살펴보자 obj.a 라는 코드로 a에 접근하게 되어 get()을 호출한다 console.log(&#39;get&#39;)을 호출한다 this.a 는 obj.a 이므로 다시 get() 을 호출한다 1~3 무한 반복그래서 obj.a에 바로 접근하면 해당 프로퍼티에 직접 접근하는 것이 아닌 내부에만 존재하는 것으로 취급하는 _a로 연결시키고 접근하고 수정하는 것이다 JavaScript : 프로토타입(prototype) 이해 프로토타입 메서드와 __proto__가 없는 객체 MDN, Object" }, { "title": "브라우저는 VSync를 어떻게 활용하고 있을까?", "url": "/posts/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80_VSync/", "categories": "CS, Web", "tags": "requestAnimationFrame, requestIdleCallback, VSync", "date": "2021-12-14 01:47:00 +0900", "snippet": "모니터는 화면을 어떻게 업데이트 하는가?간단하게 요약하면 애플리케이션이 그래픽 드라이버에게 화면을 그려달라고 요청하면 그대로 그려서 모니터에게 전달하고 전달된 내용을 우리가 보게된다.좀 더 자세히 살펴보자그래픽 드라이버그래픽 드라이버는 애플리케이션에서 받은 요청을 바로 모니터로 전달하는 것이 아니라 버퍼라는 저장 공간에서 미리 이미지를 만들어 둔다.그래픽 드라이버는 Front Buffer와 Back Buffer 의 버퍼를 두 개 가지고 있다.앞서서 얘기한 이미지가 생성시에는 Back Buffer에서 이미지가 그려지다가 다 그려지게 되면 Front Buffer와 역할을 바꾸는데 이를 Buffer Swap이라고 부른다.Back Buffer에서 이미지가 완성되고 나면 Front Buffer와 위치를 바꾸게되는데 이를 Buffer Swap이라고 한다.Buffer Swap이 끝나고 나면 사용자는 업데이트되는 화면을 볼 수 있게 된다.왜 이렇게 복잡할까?모니터는 60Hz, 144Hz 같은 화면 재생 빈도(display refresh rate)를 가지고 있다.이 빈도수만큼 (1초에 60번, 144번 만큼) 화면을 Front Buffer에 있는 이미지로 업데이트 해주는데 모니터가 화면을 업데이트하는 도중에 Buffer Swap이 일어나게 되면 이전 Front Buffer를 그리던 화면 위에 Buffer Swap으로 인해서 바뀐 Front Buffer의 내용을 이어서 그리게 된다.이런 현상을 티어링 현상이라고 부르고, 당연히 이를 막기 위해 나온 기술도 존재한다.수직 동기화(VSync)게임을 자주 하는 사람이라면 티어링은 조금 익숙한 단어일 것이고 수직 동기화도 어느정도 들어봤을 것이다.수직 동기화는 모니터가 업데이트되는 동안 Buffer Swap이 일어나지 못하게 해서 티어링 현상을 막는 기술이지만 단점이 존재한다.수직 동기화는 모니터의 화면 업데이트 주기에 맞추어서 Buffer Swap을 발생시켜야 하기 때문에 어플리케이션에서 전달 받은 이미지를 Back Buffer에 다 그렸음에도 불구하고 Front Buffer에 가지 못하고 그렇게 되면 당연히 모니터에 그릴 수 없게 된다. 그 사이에 새로운 요청이 들어온다면..? Back Buffer에는 한 줄기의 빛 조차 보지 못하고 새로운 이미지로 덧씌워지게 된다.이로 인한 프레임이 누락에 일부 FPS 유저들은 분명히 내가 먼저 쐈는데 내가 먼저 죽는 억울한 상황을 맞이하며 모니터에 돈을 투자하게 된다.프레임이 파트를 들어가기 전에 간단히 단어들을 정의하고 가자 프레임: 화면을 업데이트하는데 사용할 픽셀 데이터 프레임 타이밍: 프레임 생성/삭제 등의 시간 정보 프레임 드랍: 모니터 업데이트 주기에 새로운 프레임을 생성하지 못해서 동일한 프레임이 계속해서 보여지는 상황깔끔한 화면 움직임, 애니메이션을 위해서는 모니터 업데이트 주기 마다 새로운 프레임을 생성해주어서 프레임 드랍이 발생하지 않게 해야한다.프레임 타이밍모니터 업데이트 주기에 맞춰서 프레임 타이밍이 잘 컨트롤되고 있는 사진이다.프레임 생성이 완료되었다고 해서 다음 프레임을 생성하는게 아니라 기다렸다가 다음 주기에 맞추어서 새로 생성되고 있어서 사용자가 보지 못하는 프레임 없이 부드러운 애니메이션이 재생되고 있을 것이다.위의 사진보다 많은 프레임을 생성하고 있으니 더 부드러운 애니메이션일까?그렇지 않다 프레임 타이밍을 컨트롤하고 있지 않아서 프레임이 생성되고나면 바로 다음 프레임을 생성해버린다 그 결과 다음 모니터 주기에 반영되지 않아서 오히려 리소스만 낭비해버리게되었다.브라우저에서의 프레임 타이밍 컨트롤그럼 이제 드디어 웹 개발과 관련된 부분으로 돌아와서 질문을 던져보자면 브라우저에서 어떻게 프레임 타이밍을 컨트롤해서 부드러운 애니메이션을 보여줄 수 있을까?브라우저는 한 번의 프레임을 생성하기위해 굉장히 많은 작업을 거쳐야한다. (흔히 면접 단골 질문인 style -&amp;gt; layout -&amp;gt; paint -&amp;gt; composite 가 그 것이다.)대부분의 모니터는 60fps를 보여주고 있으니까 setInterval를 16.6ms마다 찍어내면 되는 걸까?물론 이렇게 하면 고정된 주기를 가지고 프레임은 생성하겠지만 이 주기가 모니터 업데이트 주기와 동일함을 보장받지는 못한다.VSync여기서 다시 VSync가 등장하는데 앞선 VSync를 설명할 때 모니터 업데이트 주기에 맞게 Buffer Swap을 제한한다고 했었다.모니터 업데이트 주기에 대한 정보가 VSync에 들어있기 때문에 VSync를 이용하면 모니터 업데이트 주기에 맞게 프레임을 생성해 줄 수 있다.Display refresh주기에 맞춰 호출되는 콜백어디서 많이 들어본 문장이지 않은가?프레임에 맞춰서 호출되는 콜백.. 그렇다 우리가 애니메이션을 만들 때 자주 사용하는 함수인 requestAnimationFrame(rAF)다.크로미움에서 해당 파트를 담당하고 있는 개발자분은 rAF가 만능은 아니며 모든 경우에서 모니터 업데이트 주기에 콜백이 실행되지는 않고 브라우저 스펙이 잘 맞춰져야하고 해당하는 프레임에서도 JavaScript 코드가 너무 커서도 안된다고 얘기한다.보너스 - requestIdleCallbackrAF는 많이 들어봤겠지만 이건 조금 생소한 함수다. cooperatively schedule background tasks such that they do not introduce delays to other high priority tasks that share the same event loop, such as input processing, animations and frame compositinghttps://w3c.github.io/requestidlecallback/간단히 요약하면 input, animation과 같은 이벤트 루프를 사용하지만 그들의 실행을 지연시키지 않으며 그들의 실행이 모두 끝나면 idleCallback을 실행한다어떻게 같은 이벤트 루프를 쓰면서 이러한 실행이 가능한 걸까?main thread에서의 일이 빠르게 끝난다면 다음 프레임까지 시간이 남게되는데 같은 이벤트 루프를 사용하고 있는 idleCallback가 사용하게된다. 이 역시도 브라우저에서 정확한 프레임 주기를 알고 있어야 정확한 작동이 보장된다.참고브라우저는 vsync를 어떻게 활용하고 있을까" } ]
